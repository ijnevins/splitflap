<!DOCTYPE HTML>
<html>
<head>
<title>Flippy Flap!</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.1.0/paho-mqtt.min.js"></script>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif; text-align: center; padding: 20px; background: #f0f3f5; } /* Lighter background */
  .container { 
      position: relative; /* <--- ADD THIS LINE */
      max-width: 750px; 
      margin: 0 auto; 
      background: white; 
      padding: 25px; 
      border-radius: 12px; 
      box-shadow: 0 6px 20px rgba(0,0,0,0.1); 
  }  
  h1 { font-size: 2em; margin-bottom: 20px; font-weight: 600; } /* Cleaner title */
  
  /* Input Styling */
  input[type="text"] { 
      width: 90%; padding: 12px; font-size: 1em; border-radius: 8px; border: 1px solid #ccc; 
      margin-bottom: 5px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); 
  }
  
  .reset-name-btn {
    position: absolute;    /* Sticks it to the container, not the window */
    top: 15px;             /* Distance from top edge of white box */
    left: 15px;            /* Distance from left edge of white box */
    width: auto;           
    background: #f8f9fa;   /* Light gray so it's subtle */
    color: #6c757d;
    border: 1px solid #dee2e6;
    padding: 5px 10px;     /* Smaller padding */
    border-radius: 4px;
    font-size: 0.75em;     /* Smaller text */
    cursor: pointer;
    transition: all 0.2s;
}

  .reset-name-btn:hover {
      background: #e2e6ea;
      color: #333;
  }

  /* Button Styling */
  .buttons { display: flex; justify-content: center; gap: 10px; }
  button { 
      width: 100%; padding: 12px 15px; font-size: 1em; border: none; border-radius: 8px; 
      cursor: pointer; color: white; font-weight: 600; transition: background 0.2s; 
  }
  .ian { background: #007bff; }
  .ian:hover { background: #0056b3; }
  .eleri { background: #ff69b4; } /* Retaining original pink */
  .eleri:hover { background: #e0589a; }
  
  /* Text Coloring Classes */
  .ian-text { color: #007bff; font-weight: 600; }
  .eleri-text { color: #ff69b4; font-weight: 600; }
  
  .both { background: #5a6268; } /* Dark Gray */
  .both:hover { background: #4e555b; }
  
  /* Status Boxes */
  .info-box { background: #f7f7f7; padding: 10px 15px; border-radius: 8px; margin-bottom: 15px; }
  
  /* NEW: Style for matching the live flap preview */
  .status-box { 
      background: #222; 
      color: #fff; 
      font-family: monospace; 
      font-size: 1.1em; 
      padding: 5px 0; 
      border-radius: 4px; 
      text-align: center; 
      white-space: pre; 
  }

    /* --- RESPONSIVE GRID SYSTEM --- */
  .dashboard-grid {
    display: flex;
    gap: 20px;
    text-align: left;
    align-items: flex-start;
    margin-top: 20px;
  }
  .dashboard-col { flex: 1; }

  /* --- ADD THIS NEW CLASS --- */
.status-row {
  display: flex;
  align-items: center;
  margin-bottom: 2px;
}

/* --- UPDATE YOUR MEDIA QUERY TO THIS --- */
@media (max-width: 600px) {
  /* Existing grid stack */
  .dashboard-grid { flex-direction: column; gap: 5px; }
  .dashboard-col { width: 100%; }
  
  /* NEW: This stacks the "Ian:" label on top of the black box */
  .status-row { 
      flex-direction: column; 
      align-items: stretch; 
      gap: 5px; 
  }
  /* NEW: This aligns the text to the left when stacked */
  .status-row span { 
      text-align: left !important; 
      width: 100% !important; 
      margin-bottom: 2px; 
  }
}
  
  #signin-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85); /* Dark background */
    z-index: 9999; /* Sit on top of everything */
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(5px); /* Cool blur effect */
  }

  /* The white box inside the overlay */
  .signin-box {
      background: white;
      padding: 30px;
      border-radius: 12px;
      text-align: center;
      width: 300px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
  }

  .hidden {
      display: none !important;
  }
</style>
</head>
<body>
<div id="signin-overlay" class="hidden"> <div class="signin-box">
        <h2>Welcome!</h2>
        <p>Please enter your name to start yapping.</p>
        
        <input type="text" id="username_input" placeholder="Your Name" 
               style="width: 100%; padding: 10px; margin-bottom: 15px; box-sizing: border-box; font-size: 1.1em;">
        
        <button class="ian" onclick="submitName()">Enter</button>
    </div>
</div>
  
<div class="container">
  <button class="reset-name-btn" onclick="clearName()">Change Name</button>
  <h1>Flippy Flap!</h1>
  <div style="text-align: center; margin-bottom: 15px;">
    <input type="text" id="message_input" placeholder="Enter message" autofocus maxlength="6" oninput="updateCharCount()" style="width: 90%; box-sizing: border-box; display: inline-block;">
    
    <p style="margin-top: 5px; font-size: 0.9em; color: #555;">
        Characters remaining: <span id="char_count_display">6</span>
        <span id="validation_error" style="color: red; font-weight: bold; margin-left: 10px;"></span>
    </p>

    <div class="buttons" style="margin-bottom: 10px; display: flex; justify-content: center; gap: 10px;">
      <button class="ian" onclick="sendMessage('Ian')">Send to Ian</button>
      <button class="eleri" onclick="sendMessage('Eleri')">Send to Eleri</button>
      <button class="both" onclick="sendMessage('Both')">Send to Both</button>
    </div>
    
    <p id="status" style="text-align: center; margin-top: 0; font-weight: 600; font-size: 1em; color: #28a745;">Connected to HiveMQ</p>

  </div>
  <hr style="margin: 15px 0; border: 0; border-top: 1px solid #eee;"> 
  

  <div class="dashboard-grid">

    <!-- LEFT COL: Live Flap Preview -->
    <!-- Added 'align-self: flex-start' to shrink the column height to fit content -->
    <div class="dashboard-col" style="display: flex; flex-direction: column; align-items: center; align-self: flex-start;">
      
      <h3 style="margin-top: 0; margin-bottom: 5px; text-align: center; color: #000000;">Live Preview</h3>
      
      <!-- Reduced height to 45px and adjusted margins -->
      <div id="flap_preview" class="status-box" style="width: 100%; max-width: 280px; height: 45px; display: flex; align-items: center; justify-content: center; font-size: 1.5em; margin-bottom: 5px;">------</div>
      
      <!-- Removed default margins from this paragraph to save space -->
      <p id="sent_status_message" style="text-align: center; font-size: 0.9em; font-weight: 600; margin: 0; min-height: 10px;"></p>
    </div>
    
      <div class="dashboard-col">
        <h3 style="margin-top: 0; text-align: center; color: #000000; margin-bottom: 5px;">Display Status</h3>
        
        <!-- IAN ROW: Changed to use class="status-row" -->
        <div class="status-row">
            <span class="ian-text" style="width: 50px; text-align: right; margin-right: 10px;">Ian:</span>
            <div id="status_preview_A" class="status-box" style="flex-grow: 1;">------</div>
        </div>

        <!-- ELERI ROW: Changed to use class="status-row" -->
        <div class="status-row">
            <span class="eleri-text" style="width: 50px; text-align: right; margin-right: 10px;">Eleri:</span>
            <div id="status_preview_B" class="status-box" style="flex-grow: 1;">------</div>
        </div>
      </div>
  </div>
  <hr style="margin: 0px 0; border: 0; border-top: 1px solid #ddd;"> 

  <div style="text-align: center; padding: 0 25px;"> 
      
      <h3 style="margin-bottom: 5px;">Special Characters</h3>
      <p id="char_set_display" style="font-family: monospace; font-size: 1.3em; line-height: 1.5; word-break: break-all; margin-top: 2px; color: #555;">
        Loading...
      </p>
      
      <h3 style="margin-bottom: 5px;">Message Log</h3>
      <div id="message_log" style="text-align: left; font-size: 0.9em; max-height: 150px; overflow-y: auto; padding: 10px; border: 1px solid #eee; background: #fff; border-radius: 6px; margin: 0 auto; max-width: 500px;">
        Loading history...
      </div>
  </div>
  
</div> 
<script>
  // --- REPLACE THESE WITH YOUR ACTUAL HiveMQ CREDENTIALS ---
    const MQTT_SERVER = "984187bfece9477f8f6926e896a06400.s1.eu.hivemq.cloud";  // <-- Your HiveMQ URL here
    const MQTT_USER = "ijnevs";                  // <-- SAME Username
    const MQTT_PASSWORD= "M@rl0w408";    
  // ---------------------------------------------------------
  
  const MQTT_PORT = 8884; // WebSocket port for secure cloud connection
  let mqttClient;
  
  // Function to update the simulated flap preview box
  function updateFlapPreview(rawInput) {
    const previewEl = document.getElementById('flap_preview');
    if (!previewEl) return;
    
    let formattedMessage = '';
    const maxLength = 6;
    
    // 1. Get the current value (or use the rawInput passed in)
    let message = rawInput || document.getElementById('message_input').value;
    
    // 2. Apply formatting to create the ESP32 payload (uppercase, preserve w/d)
    for (let i = 0; i < message.length; i++) {
      const char = message[i];
      const lowerChar = char.toLowerCase();
      if (lowerChar === 'w' || lowerChar === 'd') {
        formattedMessage += char; 
      } else {
        formattedMessage += char.toUpperCase(); 
      }
    }
    
    // 3. Apply the display translation (d -> ° and w -> ■)
    // We reuse the translateForDisplay function for the symbols
    let displayOutput = translateForDisplay(formattedMessage);
    
    // 4. Pad the message to 6 characters and ensure it's uppercase
    // Pad with spaces for the visual effect
    const padding = ' '.repeat(maxLength - displayOutput.length);
    displayOutput = displayOutput + padding;
    
    // 5. Render the final output
    previewEl.textContent = displayOutput;
  }

  function updateStatus(text, color = 'red') {
    const el = document.getElementById('status');
    el.textContent = text;
    el.style.color = color;
  }

  // Function to update the actual display status boxes
  function updateDisplayState(deviceId, message) {
    const el = document.getElementById(`status_preview_${deviceId}`); 
    
    if (el) {
      let displayOutput = translateForDisplay(message);
      
      const maxLength = 6;
      const padding = ' '.repeat(maxLength - displayOutput.length);
      displayOutput = displayOutput + padding;
      
      el.textContent = displayOutput;
    }
  }

 // Hardcoded character set for validation (must match the display set)
  const VALID_CHARS = [
    ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
    'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
    'Z', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'd',
    ',', '$', ' ', '.', '?', '-', '!', '@', '&', 'w', '\'', '#', ':'
  ];
  
  // Set to hold the valid characters for fast lookup (case-insensitive for letters)
  const VALID_CHARS_SET = new Set(VALID_CHARS.map(c => c.toUpperCase()));
  
  // Function to update the character count and check for invalid characters
  function updateCharCount() {
    const inputEl = document.getElementById('message_input');
    const countEl = document.getElementById('char_count_display');
    const errorEl = document.getElementById('validation_error');
    
    if (!inputEl || !countEl || !errorEl) return;

    const inputValue = inputEl.value;
    let hasInvalidChar = false;

    // 1. Live Validation
    for (const char of inputValue) {
        // Check if the uppercase version of the character is NOT in our valid set
        // This handles case-insensitivity for A-Z
        if (!VALID_CHARS_SET.has(char.toUpperCase())) {
            
            // Explicitly check for 'd' and 'w' which are case-sensitive in the set
            if (char !== 'd' && char !== 'w') {
                hasInvalidChar = true;
                break;
            }
        }
    }

    // 2. Update Validation Display
    if (hasInvalidChar) {
        errorEl.textContent = 'INVALID CHARACTER!';
        inputEl.style.border = '2px solid red';
    } else {
        errorEl.textContent = '';
        inputEl.style.border = '1px solid #ccc'; // Reset to normal
    }

    // 3. Update Character Count
    const currentLength = inputValue.length;
    const maxLength = 6;
    const remaining = maxLength - currentLength;
    
    countEl.textContent = remaining;
    
    updateFlapPreview(inputValue);

    // Change color when nearly full or if an error exists
    if (hasInvalidChar) {
        countEl.style.color = 'red';
    } else {
        countEl.style.color = (remaining <= 1) ? '#dc3545' : '#555';
    }
  }

  const MAX_HISTORY = 5; // Define how many messages to keep in the log
  const HISTORY_KEY = 'splitflap_message_history'; // Key for localStorage
  const messageInputEl = document.getElementById('message_input');

  // Loads history from browser's storage
  function loadMessageHistory() {
    const logEl = document.getElementById('message_log');
    let history = [];
    try {
      const storedHistory = localStorage.getItem(HISTORY_KEY);
      if (storedHistory) {
        history = JSON.parse(storedHistory);
      }
    } catch (e) {
      console.error("Error loading history from localStorage:", e);
    }
    renderMessageHistory(history);
    return history;
  }

// Renders the history array to the HTML element with color coding
  // Renders the history array to the HTML element with color coding
// Ensure this function matches your previous working version for time formatting and order.
// A more robust rendering function
function renderMessageHistory(history) {
    const logEl = document.getElementById('message_log');
    if (logEl && history.length > 0) {
        
        logEl.innerHTML = history.map(item => {
            
            // 1. Format the Time
            const dateObject = new Date(item.time); 
            let timestamp = '';
            if (isNaN(dateObject.getTime())) { 
                timestamp = 'Unknown Time';
            } else {
                timestamp = dateObject.toLocaleString('en-US', {
                    month: 'numeric', 
                    day: 'numeric',    
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: true
                });
            }
            
            // 2. Format the Message Content
            const displayMessage = translateForDisplay(item.message);

            // 3. Determine Class for TARGET (The person receiving the message)
            const targetClass = item.target === 'Ian' ? 'ian-text' : 'eleri-text';

            // 4. NEW: Determine Class for SENDER
            let senderClass = ''; // Default is black (no class)
            
            // Remove extra spaces from name just in case
            const safeSender = (item.sender || "").trim(); 
            
            if (safeSender === 'Ian') {
                senderClass = 'ian-text';
            } else if (safeSender === 'Eleri') {
                senderClass = 'eleri-text';
            }

            const senderName = item.sender || "Unknown";
            
            // 5. Return the HTML
            // We apply senderClass to the first <strong> tag
            return `<p style="margin: 0;">
                [${timestamp}] 
                <strong class="${senderClass}">${senderName}</strong> &rarr; 
                <strong class="${targetClass}">${item.target}:</strong> 
                ${displayMessage}
            </p>`;
        }).join('');

        // Auto-scroll to the bottom
        logEl.scrollTop = logEl.scrollHeight; 
        
    } else if (logEl) {
        logEl.innerHTML = '<p style="margin: 0; color: #888;">No messages sent yet.</p>';
    }
}

function clearName() {
    if(confirm("Sign out and change name?")) {
        localStorage.removeItem('splitflap_sender_name');
        location.reload(); // Reload page to trigger the sign-in overlay
    }
}

// 1. Function to handle the Sign In button click
// 1. Function to handle the Sign In
function submitName() {
    // Get the name from the overlay box
    const nameInput = document.getElementById('username_input');
    const name = nameInput.value.trim();

    if (name) {
        // Save to storage
        localStorage.setItem('splitflap_sender_name', name);
        
        // Populate the main UI input
        const mainInput = document.getElementById('sender_input');
        if (mainInput) {
            mainInput.value = name;
        }

        // Hide the overlay
        document.getElementById('signin-overlay').classList.add('hidden');
    } else {
        alert("Please enter a name!");
    }
}


// Saves a new message to the history and updates the display
function saveMessageToHistory(message, target) {
    // Determine the class name if still needed for the live status update
    const nameClass = target === 'Ian' ? 'ian-text' : 'eleri-text';

    fetch('/api/messages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            sender: senderName,
            target: target, 
            message: message, 
            time: new Date().getTime() 
        })
    })
    .then(response => response.json())
    .then(newHistory => {
        // After successfully posting, re-render the log with the new data from the server
        renderMessageHistory(newHistory); 
    })
    .catch(err => console.error("Could not save to server:", err));
}

const API_BASE_URL = 'https://splitflap-api.onrender.com';

function loadAndRenderInitialHistory() {
    fetch(`${API_BASE_URL}/api/messages`)
        .then(response => response.json())
        .then(history => {
            renderMessageHistory(history);
        })
        .catch(err => {
            console.error("Could not load initial history from server:", err);
            // Optionally, display a message in the log area if load fails
            document.getElementById('message_log').innerHTML = '<p style="margin: 0; color: red;">Failed to load history from server.</p>';
        });
}

function translateForDisplay(message) {
    let translatedMessage = message.replace(/d/g, '\u00B0');
    translatedMessage = translatedMessage.replace(/w/g, '\u25A0');
    
    return translatedMessage;
  }
  
  // Hardcoded function to filter and display only special characters
  function displaySpecialCharacterSet() {
    
    // Hardcode the full character set from your C++ definition
    const fullCharArray = [
      ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
      'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
      'Z', '(', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '\u00B0',
      ',', '$', ')', '.', '?', '-', '!', '@', '&', '\u25A1', '\'', '#', ':'
    ];
    
    const displayEl = document.getElementById('char_set_display');
    
    // --- CORE FILTERING LOGIC ---
    const specialCharsArray = fullCharArray.filter(char => {
        // Exclude letters (A-Z), numbers (0-9), and the space character.
        // The regex /[A-Z0-9]/i tests for all cases of letters and numbers.
        const isAlphanumeric = /[A-Z0-9]/i.test(char);
        
        // Check if the character is one of the essential symbols (d or w)
        const isEssentialSymbol = (char === 'd' || char === 'w');

        // A character is "special" if:
        // 1. It is NOT alphanumeric AND NOT a space AND NOT a parenthesis.
        // OR
        // 2. It IS one of the essential symbols (d or w).
        
        const isPunctuationOrSymbol = !isAlphanumeric && char !== ' ' && char !== '(' && char !== ')';

        return isPunctuationOrSymbol || isEssentialSymbol;
    });
    
    // Join the filtered array into a string separated by two spaces for visual effect
    const displayString = specialCharsArray.join('    ');
    
    
    // Ensure the display element exists before setting textContent (safety first!)
    if (displayEl) {
        displayEl.textContent = displayString;
    }
  }

  function connectMQTT() {
    const clientId = 'remote_webpage_' + Math.random().toString(16).substr(2, 8);
    mqttClient = new Paho.Client(MQTT_SERVER, MQTT_PORT, "/mqtt", clientId);
    loadMessageHistory();
    // --- NEW: Add the onMessageArrived Handler ---
    mqttClient.onMessageArrived = (message) => {
        const topic = message.destinationName;
        const payload = message.payloadString;
        
        if (topic === 'splitflap/state/A') {
          updateDisplayState('A', payload);
        } else if (topic === 'splitflap/state/B') {
          updateDisplayState('B', payload);
        }
    };
    // --- END NEW ---

    mqttClient.onConnectionLost = (responseObject) => {
        updateStatus(`Connection Lost: ${responseObject.errorMessage}`);
        setTimeout(connectMQTT, 5000); 
    };
    
    mqttClient.connect({
      userName: MQTT_USER,
      password: MQTT_PASSWORD,
      useSSL: true,
      onSuccess: () => {
        updateStatus('Connected to HiveMQ', 'green');
        displaySpecialCharacterSet();
        updateDisplayState('A', '------');
        updateDisplayState('B', '------');
        // --- NEW: Subscribe to the state topics ---
        mqttClient.subscribe('splitflap/state/A', { qos: 1 });
        mqttClient.subscribe('splitflap/state/B', { qos: 1 });
        // --- END NEW ---
      },
      onFailure: (err) => {
        updateStatus(`Connection Failed: ${err.errorMessage}`, 'red');
        setTimeout(connectMQTT, 5000); 
      }
    });
  }
  
async function sendMessage(target) {
    // 1. Connection and Input Validation
    if (!mqttClient || !mqttClient.isConnected()) {
        alert("Not connected to MQTT. Please refresh the page.");
        return;
    }
    
    // Use the globally defined messageInputEl
    let message = messageInputEl.value; 
    
    if (!message) {
        alert("Please enter a message.");
        return;
    }

    const errorEl = document.getElementById('validation_error');
    if (errorEl && errorEl.textContent) {
        alert("Please remove the invalid characters before sending.");
        return;
    }

    // 2. Format Message for Split-Flap (Uppercase, preserve 'w'/'d' case)
    let formattedMessage = '';
    for (let char of message) {
      const lowerChar = char.toLowerCase();
      if (lowerChar === 'w' || lowerChar === 'd') {
        formattedMessage += char;
      } else {
        formattedMessage += char.toUpperCase();
      }
    }

    const userFeedback = translateForDisplay(formattedMessage);
    
    // ==========================================================
    // Core Logic Wrapper for API POST and MQTT Publish
    // ==========================================================
    async function sendToSingleTarget(singleTarget) {
        const topic = (singleTarget === 'Ian') ? 'splitflap/device/A' : 'splitflap/device/B';
        const targetColor = (singleTarget === 'Ian') ? '#007bff' : '#ff69b4';

        const senderName = localStorage.getItem('splitflap_sender_name') || "Anonymous";
        
        // --- 3. Express Server API (Logging) ---
        // Note: Using relative path '/api/messages' works best if serving file from server
        const response = await fetch(`${API_BASE_URL}/api/messages`, {
            method: 'POST', 
            headers: { 
                'Accept-Encoding': 'gzip, deflate, identity',
                'Content-Type': 'application/json' 
            },
            body: JSON.stringify({ 
                sender: senderName,
                target: singleTarget,
                message: formattedMessage, 
                time: new Date().getTime() 
            })
        });

        if (!response.ok) {
            throw new Error(`Server failed to save history for ${singleTarget}.`);
        }

        const responseText = await response.text(); 
        const updatedHistory = JSON.parse(responseText); 
        
        // --- 4. MQTT Broker (Hardware Control) ---
        const mqttMessage = new Paho.Message(formattedMessage);
        mqttMessage.destinationName = topic;
        mqttClient.send(mqttMessage);
        
        return { success: true, history: updatedHistory, color: targetColor };
    }
    
    // ==========================================================
    // 5. Target Handling Logic
    // ==========================================================
    try {
        if (target === 'Both') {
            // Run Ian's send, wait, then run Eleri's send
            // We use 'await' sequentially to ensure order, or Promise.all for speed.
            // Sequential is safer for the message log rendering order.
            const ianResult = await sendToSingleTarget('Ian');
            const eleriResult = await sendToSingleTarget('Eleri');

            // --- IMPROVED FEEDBACK LOGIC ---
            let statusMsg = '';
            let statusColor = '';
            const bothSuccess = ianResult.success && eleriResult.success;
            
            if (bothSuccess) {
                statusMsg = `Sent "${userFeedback}" to Ian and Eleri!`;
                statusColor = '#28a745';
            } else if (ianResult.success) {
                statusMsg = `Sent to Ian, but failed for Eleri.`;
                statusColor = 'orange';
            } else if (eleriResult.success) {
                statusMsg = `Sent to Eleri, but failed for Ian.`;
                statusColor = 'orange';
            } else {
                statusMsg = `Failed to send to both Ian & Eleri.`;
                statusColor = 'red';
            }

            // Update log using the last result (contains most up-to-date history)
            renderMessageHistory(eleriResult.history || ianResult.history); 
            updateStatus(statusMsg, statusColor); 
            
        } else {
            // --- SINGLE TARGET LOGIC (Ian OR Eleri) ---
            const result = await sendToSingleTarget(target);

            // Update log using the result from the single send
            renderMessageHistory(result.history);
            
            // Provide single recipient feedback
            updateStatus(`Sent "${userFeedback}" to ${target}!`, result.color);
        }

        // --- 6. Final Cleanup ---
        messageInputEl.value = ''; 
        updateCharCount(); 

    } catch (e) {
        // If an error occurs in EITHER fetch or MQTT, the whole transaction is flagged
        updateStatus(`Error sending message: ${e.message}`, 'red');
    }
}
// REPLACE ALL window.addEventListener BLOCKS WITH THIS ONE
window.addEventListener('load', function() {
    // 1. Check for a saved name immediately
    const savedName = localStorage.getItem('splitflap_sender_name');
    
    // 2. Logic: If name exists, use it. If not, show the sign-in overlay.
    if (savedName) {
        // User is known: Auto-fill the main input and ensure overlay is hidden
        const senderInput = document.getElementById('sender_input');
        if (senderInput) {
            senderInput.value = savedName;
            // Optional: Make it read-only so they don't accidentally change it
            // senderInput.readOnly = true; 
        }
        document.getElementById('signin-overlay').classList.add('hidden');
    } else {
        // User is new: Show the overlay to force sign-in
        document.getElementById('signin-overlay').classList.remove('hidden');
    }

    // 3. Connect to services
    connectMQTT(); 
    loadAndRenderInitialHistory(); 
});
</script>

</body>
</html>